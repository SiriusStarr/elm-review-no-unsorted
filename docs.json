[{"name":"NoUnsortedCases","comment":" Reports case patterns that are not in the \"proper\" order.\n\nðŸ”§ Running with `--fix` will automatically sort the patterns.\n\nThe proper order of custom types is the order in which they are defined in your\nsource files, and the order of other patterns may be specified in the rule\nconfiguration. See the \"Configuration\" section below for more information.\n\n    config =\n        [ NoUnsortedCases.rule NoUnsortedCases.defaults\n        ]\n\n\n## Fail\n\n    type Custom\n        = Foo\n        | Bar\n        | Baz\n\n    func1 c =\n        case c of\n            Bar ->\n                \"bar\"\n\n            Foo ->\n                \"foo\"\n\n            Baz ->\n                \"baz\"\n\n    func2 cs =\n        case cs of\n            [ Bar ] ->\n                \"bar\"\n\n            [ Foo ] ->\n                \"foo\"\n\n            [ Foo, Foo ] ->\n                \"foofoo\"\n\n            [ Baz ] ->\n                \"baz\"\n\n            _ ->\n                \"other\"\n\n    func3 c =\n        case c of\n            Nothing ->\n                \"\"\n\n            Just Bar ->\n                \"bar\"\n\n            Just Foo ->\n                \"foo\"\n\n            Just Baz ->\n                \"baz\"\n\n    func4 c1 c2 =\n        case ( c1, c2 ) of\n            ( Foo, Baz ) ->\n                \"foo baz\"\n\n            ( Foo, Bar ) ->\n                \"foo bar\"\n\n            ( Bar, Foo ) ->\n                \"bar foo\"\n\n            ( Baz, Foo ) ->\n                \"baz foo\"\n\n            _ ->\n                \"other\"\n\n\n## Success\n\n    type Custom\n        = Foo\n        | Bar\n        | Baz\n\n    func1 c =\n        case c of\n            Foo ->\n                \"foo\"\n\n            Bar ->\n                \"bar\"\n\n            Baz ->\n                \"baz\"\n\n    func2 cs =\n        case cs of\n            [ Foo ] ->\n                \"foo\"\n\n            [ Foo, Foo ] ->\n                \"foofoo\"\n\n            [ Bar ] ->\n                \"bar\"\n\n            [ Baz ] ->\n                \"baz\"\n\n            _ ->\n                \"other\"\n\n    func3 c =\n        case c of\n            Just Foo ->\n                \"foo\"\n\n            Just Bar ->\n                \"bar\"\n\n            Just Baz ->\n                \"baz\"\n\n            Nothing ->\n                \"\"\n\n    func4 c1 c2 =\n        case ( c1, c2 ) of\n            ( Foo, Bar ) ->\n                \"foo bar\"\n\n            ( Foo, Baz ) ->\n                \"foo baz\"\n\n            ( Bar, Foo ) ->\n                \"bar foo\"\n\n            ( Baz, Foo ) ->\n                \"baz foo\"\n\n            _ ->\n                \"other\"\n\n\n## When (not) to enable this rule\n\nThis rule is useful when you want to ensure that you pattern match in a\nconsistent, predictable order, that is consistent with the order in which a type\nwas defined, as well as ensuring (optionally) that literal patterns and the like\nare sorted.\n\nThis rule is not useful when you want to be able to write case patterns in\ndifferent orders throughout your codebase, e.g. if you want to emphasize what\npattern is most important at any given point or glean a tiny bit of performance\nout of matching the more commonly-expected patterns first.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template SiriusStarr/elm-review-no-unsorted/example --rules NoUnsortedCases\n```\n\n\n## Rule\n\n@docs rule\n\n\n## Configuration\n\n@docs RuleConfig, defaults, sortOnlyMatchingTypes, doNotSortLiterals, doNotSortTypesFromDependencies, sortTypesFromDependenciesAlphabetically, sortListPatternsByLength, doNotLookPastUnsortable\n\n","unions":[{"name":"RuleConfig","comment":" Configuration for this rule. Create a new one with `defaults` and use\n`doNotSortLiterals`, `sortListPatternsByLength`, etc. to alter it.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"defaults","comment":" The default configuration, with the following behavior:\n\n  - All custom types are sorted. (This can be restricted by using\n    `sortOnlyMatchingTypes`.)\n\n  - Literal patterns (`String`, `Int`, etc.) are sorted in the natural order for their type.\n\n  - Types imported from dependencies are sorted in declaration order, i.e. in the order they appear in the dependency's source file (or more technically in its documentation); this is identical to the behavior of types defined within your own modules.\n\n  - Lists are sorted elementwise, by comparing the elements sequentially at each\n    position (from left to right).\n\n  - Unsortable patterns can be looked beyond to resolve ties, for example:\n\n```\nfunc custom =\n    case custom of\n        Container { field } Bar ->\n            not field\n\n        Container { field } Baz ->\n            field\n\n        Container { field } Foo ->\n            field\n```\n\nwill be sorted to\n\n    func custom =\n        case custom of\n            Container { field } Foo ->\n                field\n\n            Container { field } Bar ->\n                not field\n\n            Container { field } Baz ->\n                field\n\nUse `doNotSortLiterals`, `sortListPatternsByLength`, etc. to alter any of this\nbehavior, e.g.\n\n    config =\n        [ NoUnsortedCases.defaults\n            |> NoUnsortedCases.doNotSortLiterals\n            |> NoUnsortedCases.sortListPatternsByLength\n            |> NoUnsortedCases.rule\n        ]\n\n","type":"NoUnsortedCases.RuleConfig"},{"name":"doNotLookPastUnsortable","comment":" Do not look beyond unsortable patterns, rendering the following unsortable:\n\n    func custom =\n        case custom of\n            Container { field } Bar ->\n                not field\n\n            Container { field } Baz ->\n                field\n\n            Container { field } Foo ->\n                field\n\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"doNotSortLiterals","comment":" Change the behavior of the rule to **not** sort literal patterns. If\nliterals are not sorted, case expressions that would require sorting literals\ncannot be sorted and will thus be ignored by the rule.\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"doNotSortTypesFromDependencies","comment":" Do not sort types from dependencies at all. Note that this will render\nunsortable any patterns requiring types from dependencies to be sorted.\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"rule","comment":" Reports case patterns that are not in the \"proper\" order.\n","type":"NoUnsortedCases.RuleConfig -> Review.Rule.Rule"},{"name":"sortListPatternsByLength","comment":" List patterns may be sorted in one of two ways:\n\n  - Elementwise (**default**) -- Patterns are sorted by comparing elements\n    sequentially at each position (from left to right). This is the same\n    behavior as `List.sort` (which is why it is the default).\n  - Length First -- Shorter patterns always come before longer pattern, with patterns of the same length sorted elementwise at each position.\n\nNote that uncons patterns are considered the length of their matching list, with\nwildcard patterns considered to have infinite length for the purposes of\nsorting. This is necessary to ensure that earlier patterns are not erroneously\nmatched by wildcards.\n\n**Elementwise**\n\n    case list of\n        [] ->\n            \"\"\n\n        [ 1 ] ->\n            \"1\"\n\n        [ 1, 1 ] ->\n            \"11\"\n\n        [ 1, 1, 1 ] ->\n            \"111\"\n\n        [ 1, 2 ] ->\n            \"12\"\n\n        [ 1, 3 ] ->\n            \"13\"\n\n        [ 2 ] ->\n            \"2\"\n\n        [ 2, 1 ] ->\n            \"21\"\n\n        [ 2, 2 ] ->\n            \"22\"\n\n        [ 2, 3 ] ->\n            \"23\"\n\n        [ 3 ] ->\n            \"3\"\n\n        _ ->\n            \"Too many...\"\n\n**Length First**\n\n    case list of\n        [] ->\n            \"\"\n\n        [ 1 ] ->\n            \"1\"\n\n        [ 2 ] ->\n            \"2\"\n\n        [ 3 ] ->\n            \"3\"\n\n        [ 1, 1 ] ->\n            \"11\"\n\n        [ 1, 2 ] ->\n            \"12\"\n\n        [ 1, 3 ] ->\n            \"13\"\n\n        [ 2, 1 ] ->\n            \"21\"\n\n        [ 2, 2 ] ->\n            \"22\"\n\n        [ 2, 3 ] ->\n            \"23\"\n\n        [ 1, 1, 1 ] ->\n            \"111\"\n\n        _ ->\n            \"Too many...\"\n\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"sortOnlyMatchingTypes","comment":" Restrict custom type sorting to only those matching a provided predicate.\nThis function takes two strings, the first being the full module name of a type,\ne.g. `\"Review.Rule\"` and the second being the name of a type, e.g. `\"Rule\"`, and\nreturns a `Bool` indicating whether the type should be sorted (with `True`\nmeaning sortable). For example:\n\nModule Foo:\n\n    module Foo exposing (Foo(..))\n\n    type Foo\n        = Foo\n        | Bar\n        | Baz\n\nModule Main:\n\n    module Main exposing (..)\n\n    type Msg\n        = ButtonPressed\n        | ButtonClicked\n\nModule ReviewConfig:\n\n    onlyMsg moduleName typeName =\n        case ( moduleName, typeName ) of\n            ( \"Main\", \"Msg\" ) ->\n                True\n\n            _ ->\n                False\n\n    config =\n        [ NoUnsortedCases.defaults\n            |> NoUnsortedCases.sortOnlyMatchingTypes onlyMsg\n            |> NoUnsortedCases.rule\n        ]\n\nwill sort the following pattern:\n\n    case msg of\n        ButtonClicked ->\n            ( { model | clicked = True }, Cmd.none )\n\n        ButtonPressed ->\n            ( { model | pressed = True }, Cmd.none )\n\nbut will not sort:\n\n    case foo of\n        Bar ->\n            \"bar\"\n\n        Baz ->\n            \"baz\"\n\n        Foo ->\n            \"foo\"\n\n","type":"(String.String -> String.String -> Basics.Bool) -> NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"sortTypesFromDependenciesAlphabetically","comment":" Sort custom types imported from dependencies (including `Basics` types like `Maybe` and `Bool`) alphabetically, rather than by their source order in the dependency's source code.\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"}],"binops":[]}]