[{"name":"NoUnsortedCases","comment":" Reports case patterns that are not in the \"proper\" order.\n\nðŸ”§ Running with `--fix` will automatically sort the patterns.\n\nThe proper order of custom types is the order in which they are defined in your\nsource files, and the order of other patterns may be specified in the rule\nconfiguration. See the [Configuration](#Configuration) section below for more\ninformation.\n\n    config =\n        [ NoUnsortedCases.rule NoUnsortedCases.defaults\n        ]\n\n\n## Fail\n\n    type Custom\n        = Foo\n        | Bar\n        | Baz\n\n    func1 c =\n        case c of\n            Bar ->\n                \"bar\"\n\n            Foo ->\n                \"foo\"\n\n            Baz ->\n                \"baz\"\n\n    func2 cs =\n        case cs of\n            [ Bar ] ->\n                \"bar\"\n\n            [ Foo ] ->\n                \"foo\"\n\n            [ Foo, Foo ] ->\n                \"foofoo\"\n\n            [ Baz ] ->\n                \"baz\"\n\n            _ ->\n                \"other\"\n\n    func3 c =\n        case c of\n            Nothing ->\n                \"\"\n\n            Just Bar ->\n                \"bar\"\n\n            Just Foo ->\n                \"foo\"\n\n            Just Baz ->\n                \"baz\"\n\n    func4 c1 c2 =\n        case ( c1, c2 ) of\n            ( Foo, Baz ) ->\n                \"foo baz\"\n\n            ( Foo, Bar ) ->\n                \"foo bar\"\n\n            ( Bar, Foo ) ->\n                \"bar foo\"\n\n            ( Baz, Foo ) ->\n                \"baz foo\"\n\n            _ ->\n                \"other\"\n\n\n## Success\n\n    type Custom\n        = Foo\n        | Bar\n        | Baz\n\n    func1 c =\n        case c of\n            Foo ->\n                \"foo\"\n\n            Bar ->\n                \"bar\"\n\n            Baz ->\n                \"baz\"\n\n    func2 cs =\n        case cs of\n            [ Foo ] ->\n                \"foo\"\n\n            [ Foo, Foo ] ->\n                \"foofoo\"\n\n            [ Bar ] ->\n                \"bar\"\n\n            [ Baz ] ->\n                \"baz\"\n\n            _ ->\n                \"other\"\n\n    func3 c =\n        case c of\n            Just Foo ->\n                \"foo\"\n\n            Just Bar ->\n                \"bar\"\n\n            Just Baz ->\n                \"baz\"\n\n            Nothing ->\n                \"\"\n\n    func4 c1 c2 =\n        case ( c1, c2 ) of\n            ( Foo, Bar ) ->\n                \"foo bar\"\n\n            ( Foo, Baz ) ->\n                \"foo baz\"\n\n            ( Bar, Foo ) ->\n                \"bar foo\"\n\n            ( Baz, Foo ) ->\n                \"baz foo\"\n\n            _ ->\n                \"other\"\n\n\n## When (not) to enable this rule\n\nThis rule is useful when you want to ensure that you pattern match in a\nconsistent, predictable order, that is consistent with the order in which a type\nwas defined, as well as ensuring (optionally) that literal patterns and the like\nare sorted.\n\nThis rule is not useful when you want to be able to write case patterns in\ndifferent orders throughout your codebase, e.g. if you want to emphasize what\npattern is most important at any given point or glean a tiny bit of performance\nout of matching the more commonly-expected patterns first.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template SiriusStarr/elm-review-no-unsorted/example --rules NoUnsortedCases\n```\n\n\n## Rule\n\n@docs rule\n\n\n## Configuration\n\n@docs RuleConfig, defaults, sortOnlyMatchingTypes, doNotSortLiterals, doNotSortTypesFromDependencies, sortTypesFromDependenciesAlphabetically, sortListPatternsByLength, doNotLookPastUnsortable\n\n","unions":[{"name":"RuleConfig","comment":" Configuration for this rule. Create a new one with `defaults` and use\n`doNotSortLiterals`, `sortListPatternsByLength`, etc. to alter it.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"defaults","comment":" The default configuration, with the following behavior:\n\n  - All custom types are sorted. (This can be restricted by using\n    `sortOnlyMatchingTypes`.)\n\n  - Literal patterns (`String`, `Int`, etc.) are sorted in the natural order for their type.\n\n  - Types imported from dependencies are sorted in declaration order, i.e. in the order they appear in the dependency's source file (or more technically in its documentation); this is identical to the behavior of types defined within your own modules.\n\n  - Lists are sorted elementwise, by comparing the elements sequentially at each\n    position (from left to right).\n\n  - Unsortable patterns can be looked beyond to resolve ties, for example:\n\n```\nfunc custom =\n    case custom of\n        Container { field } Bar ->\n            not field\n\n        Container { field } Baz ->\n            field\n\n        Container { field } Foo ->\n            field\n```\n\nwill be sorted to\n\n    func custom =\n        case custom of\n            Container { field } Foo ->\n                field\n\n            Container { field } Bar ->\n                not field\n\n            Container { field } Baz ->\n                field\n\nUse `doNotSortLiterals`, `sortListPatternsByLength`, etc. to alter any of this\nbehavior, e.g.\n\n    config =\n        [ NoUnsortedCases.defaults\n            |> NoUnsortedCases.doNotSortLiterals\n            |> NoUnsortedCases.sortListPatternsByLength\n            |> NoUnsortedCases.rule\n        ]\n\n","type":"NoUnsortedCases.RuleConfig"},{"name":"doNotLookPastUnsortable","comment":" Do not look beyond unsortable patterns, rendering the following unsortable:\n\n    func custom =\n        case custom of\n            Container { field } Bar ->\n                not field\n\n            Container { field } Baz ->\n                field\n\n            Container { field } Foo ->\n                field\n\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"doNotSortLiterals","comment":" Change the behavior of the rule to **not** sort literal patterns. If\nliterals are not sorted, case expressions that would require sorting literals\ncannot be sorted and will thus be ignored by the rule.\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"doNotSortTypesFromDependencies","comment":" Do not sort types from dependencies at all. Note that this will render\nunsortable any patterns requiring types from dependencies to be sorted.\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"rule","comment":" Reports case patterns that are not in the \"proper\" order.\n","type":"NoUnsortedCases.RuleConfig -> Review.Rule.Rule"},{"name":"sortListPatternsByLength","comment":" List patterns may be sorted in one of two ways:\n\n  - Elementwise (**default**) -- Patterns are sorted by comparing elements\n    sequentially at each position (from left to right). This is the same\n    behavior as `List.sort` (which is why it is the default).\n  - Length First -- Shorter patterns always come before longer pattern, with patterns of the same length sorted elementwise at each position.\n\nNote that uncons patterns are considered the length of their matching list, with\nwildcard patterns considered to have infinite length for the purposes of\nsorting. This is necessary to ensure that earlier patterns are not erroneously\nmatched by wildcards.\n\n**Elementwise**\n\n    case list of\n        [] ->\n            \"\"\n\n        [ 1 ] ->\n            \"1\"\n\n        [ 1, 1 ] ->\n            \"11\"\n\n        [ 1, 1, 1 ] ->\n            \"111\"\n\n        [ 1, 2 ] ->\n            \"12\"\n\n        [ 1, 3 ] ->\n            \"13\"\n\n        [ 2 ] ->\n            \"2\"\n\n        [ 2, 1 ] ->\n            \"21\"\n\n        [ 2, 2 ] ->\n            \"22\"\n\n        [ 2, 3 ] ->\n            \"23\"\n\n        [ 3 ] ->\n            \"3\"\n\n        _ ->\n            \"Too many...\"\n\n**Length First**\n\n    case list of\n        [] ->\n            \"\"\n\n        [ 1 ] ->\n            \"1\"\n\n        [ 2 ] ->\n            \"2\"\n\n        [ 3 ] ->\n            \"3\"\n\n        [ 1, 1 ] ->\n            \"11\"\n\n        [ 1, 2 ] ->\n            \"12\"\n\n        [ 1, 3 ] ->\n            \"13\"\n\n        [ 2, 1 ] ->\n            \"21\"\n\n        [ 2, 2 ] ->\n            \"22\"\n\n        [ 2, 3 ] ->\n            \"23\"\n\n        [ 1, 1, 1 ] ->\n            \"111\"\n\n        _ ->\n            \"Too many...\"\n\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"sortOnlyMatchingTypes","comment":" Restrict custom type sorting to only those matching a provided predicate.\nThis function takes two strings, the first being the full module name of a type,\ne.g. `\"Review.Rule\"` and the second being the name of a type, e.g. `\"Rule\"`, and\nreturns a `Bool` indicating whether the type should be sorted (with `True`\nmeaning sortable). For example:\n\nModule Foo:\n\n    module Foo exposing (Foo(..))\n\n    type Foo\n        = Foo\n        | Bar\n        | Baz\n\nModule Main:\n\n    module Main exposing (..)\n\n    type Msg\n        = ButtonPressed\n        | ButtonClicked\n\nModule ReviewConfig:\n\n    onlyMsg moduleName typeName =\n        case ( moduleName, typeName ) of\n            ( \"Main\", \"Msg\" ) ->\n                True\n\n            _ ->\n                False\n\n    config =\n        [ NoUnsortedCases.defaults\n            |> NoUnsortedCases.sortOnlyMatchingTypes onlyMsg\n            |> NoUnsortedCases.rule\n        ]\n\nwill sort the following pattern:\n\n    case msg of\n        ButtonClicked ->\n            ( { model | clicked = True }, Cmd.none )\n\n        ButtonPressed ->\n            ( { model | pressed = True }, Cmd.none )\n\nbut will not sort:\n\n    case foo of\n        Bar ->\n            \"bar\"\n\n        Baz ->\n            \"baz\"\n\n        Foo ->\n            \"foo\"\n\n","type":"(String.String -> String.String -> Basics.Bool) -> NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"},{"name":"sortTypesFromDependenciesAlphabetically","comment":" Sort custom types imported from dependencies (including `Basics` types like `Maybe` and `Bool`) alphabetically, rather than by their source order in the dependency's source code.\n","type":"NoUnsortedCases.RuleConfig -> NoUnsortedCases.RuleConfig"}],"binops":[]},{"name":"NoUnsortedLetDeclarations","comment":"\n\n\n## Rule\n\n@docs rule\n\n\n## Configuration\n\n@docs RuleConfig, sortLetDeclarations\n\n\n## Orderings\n\n@docs alphabetically, usedInExpressionFirst, usedInExpressionLast, usedInOtherDeclarationsLast, usedInOtherDeclarationsFirst, valuesBeforeFunctions, valuesAfterFunctions\n\n","unions":[{"name":"RuleConfig","comment":" Configuration for this rule. Create a new one with `sortLetDeclarations` and use\norderings to create a hierarchy of sorting.\n","args":["r"],"cases":[]}],"aliases":[],"values":[{"name":"alphabetically","comment":" Sort declarations alphabetically by the name of their binding. For\ndestructurings, this will be the name of the actual bindings that are made, in\norder. For example, the following is sorted alphabetically:\n\n    let\n        (Opaque a) =\n            i\n\n        ( b, z ) =\n            j\n\n        { c, y } =\n            k\n\n        d =\n            l\n    in\n    x\n\n","type":"NoUnsortedLetDeclarations.RuleConfig { r | noAlphabetical : () } -> NoUnsortedLetDeclarations.RuleConfig r"},{"name":"rule","comment":" Reports `let` declarations that are not in the \"proper\" order.\n\nðŸ”§ Running with `--fix` will automatically sort the declarations.\n\nThe proper order of declarations is specified in the rule configuration. See the\n[Configuration](#Configuration) section below for more information.\n\n    config =\n        [ NoUnsortedLetDeclarations.rule\n            (NoUnsortedLetDeclarations.sortLetDeclarations\n                |> NoUnsortedLetDeclarations.usedInExpressionFirst\n                |> NoUnsortedLetDeclarations.alphabetically\n            )\n        ]\n\n\n## Fail\n\n    a =\n        let\n            -- These are used in the expression\n            x =\n                a\n\n            y =\n                b\n\n            -- These are not\n            b =\n                j\n\n            a =\n                i\n        in\n        x + y\n\n    b =\n        let\n            -- These are not used in the expression\n            a =\n                i\n\n            b =\n                j\n\n            -- These are\n            x =\n                a\n\n            y =\n                b\n        in\n        x + y\n\n\n## Success\n\n    a =\n        let\n            -- These are used in the expression\n            x =\n                a\n\n            y =\n                b\n\n            -- These are not\n            a =\n                i\n\n            b =\n                j\n        in\n        x + y\n\n\n## When (not) to enable this rule\n\nThis rule is useful when you want to ensure that your `let` declarations are in\na consistent, predictable order.\n\nThis rule is not useful when you want to be able to write `let` declarations in\nvarying orders throughout your codebase, e.g. if you want to emphasize what\nis most important on a case-by-case basis.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template SiriusStarr/elm-review-no-unsorted/example --rules NoUnsortedLetDeclarations\n```\n\n","type":"NoUnsortedLetDeclarations.RuleConfig r -> Review.Rule.Rule"},{"name":"sortLetDeclarations","comment":" Create a new `RuleConfig`. Use the various orderings to then specify\nprimary and fallback orderings.\n","type":"NoUnsortedLetDeclarations.RuleConfig { noAlphabetical : (), noArgCount : (), noUsedInOther : (), noUsedInExpression : () }"},{"name":"usedInExpressionFirst","comment":" Sort declarations with those used in the expression of the `let` block\ncoming first, then those that aren't. Ties will be broken by the next specified\nordering. For example, the following is sorted by this ordering and then\nalphabetically:\n\n    let\n        -- These are used in the expression\n        x =\n            a\n\n        y =\n            b\n\n        -- These are not\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n\n","type":"NoUnsortedLetDeclarations.RuleConfig { r | noUsedInExpression : () } -> NoUnsortedLetDeclarations.RuleConfig r"},{"name":"usedInExpressionLast","comment":" Sort declarations with those used in the expression of the `let` block\ncoming last, with those that aren't coming first. Ties will be broken by the\nnext specified ordering. For example, the following is sorted by this ordering\nand then alphabetically:\n\n    let\n        -- These are not used in the expression\n        x =\n            i\n\n        y =\n            j\n\n        -- These are used in the expression\n        a =\n            x\n\n        b =\n            y\n    in\n    a + b\n\n","type":"NoUnsortedLetDeclarations.RuleConfig { r | noUsedInExpression : () } -> NoUnsortedLetDeclarations.RuleConfig r"},{"name":"usedInOtherDeclarationsFirst","comment":" Sort declarations with those used in other declarations coming before those\nthat are not. Ties will be broken by the next specified ordering. For example,\nthe following is sorted by this ordering and then alphabetically:\n\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    0\n\n","type":"NoUnsortedLetDeclarations.RuleConfig { r | noUsedInOther : () } -> NoUnsortedLetDeclarations.RuleConfig r"},{"name":"usedInOtherDeclarationsLast","comment":" Sort declarations with those used in other declarations coming after those\nthat are not. Ties will be broken by the next specified ordering. For example,\nthe following is sorted by this ordering and then alphabetically:\n\n    let\n        a =\n            x\n\n        b =\n            y\n\n        x =\n            i\n\n        y =\n            j\n    in\n    0\n\n","type":"NoUnsortedLetDeclarations.RuleConfig { r | noUsedInOther : () } -> NoUnsortedLetDeclarations.RuleConfig r"},{"name":"valuesAfterFunctions","comment":" Sort declarations that do not have arguments after those that do. Since no\ntype inference is performed, this does not guarantee that some things that are\nfunctions will not be sorted with values. For example, the following is sorted\nby this ordering and then alphabetically:\n\n    let\n        -- These have arguments\n        a i =\n            i\n\n        b j =\n            j\n\n        -- These do not\n        x =\n            a\n\n        y =\n            b\n    in\n    x + y\n\n","type":"NoUnsortedLetDeclarations.RuleConfig { r | noArgCount : () } -> NoUnsortedLetDeclarations.RuleConfig r"},{"name":"valuesBeforeFunctions","comment":" Sort declarations that do not have arguments before those that do. Since no\ntype inference is performed, this does not guarantee that some things that are\nfunctions will not be sorted with values. For example, the following is sorted\nby this ordering and then alphabetically:\n\n    let\n        -- These do not have arguments\n        x =\n            a\n\n        y =\n            b\n\n        -- These do\n        a i =\n            i\n\n        b j =\n            j\n    in\n    x + y\n\n","type":"NoUnsortedLetDeclarations.RuleConfig { r | noArgCount : () } -> NoUnsortedLetDeclarations.RuleConfig r"}],"binops":[]}]